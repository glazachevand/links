Хорошие стили для верстальщика

https://habr.com/ru/post/648537/

- flex-wrap: wrap; - для нескольких элементов на строке

- Между элементами в строке должен быть margin. Проверить для заголовков.

- Учет длинного контента. Добавление многоточия:
.username {
  	white-space: nowrap; /* Запрещаем перенос строк */
    overflow: hidden; /* Обрезаем все, что не помещается в область */
    text-overflow: ellipsis; /* Добавляем многоточие в конце */
}

- Адаптив картинок.
.card__image { object-fit: cover; }

- Максимальная ширина IMG. Не забудьте установить max-width: 100% для всех изображений, чтобы они не вылезали за пределы блоков, в которых находятся. 
img {
    max-width: 100%;
    object-fit: cover;
}

- Блокировка цепочки прокрутки. Вы когда-нибудь открывали модальное окно и начинали скроллить, а затем, когда вы доходите до конца и продолжаете прокручивать, содержимое под модальным окном (элемент body) будет прокручиваться? Это называется цепочкой прокрутки (scroll chaining). Решение:
.modal__content {
    overscroll-behavior-y: contain;
    overflow-y: auto;
}

- Резервное значение CSS-переменной
Переменные CSS все чаще используются в веб-дизайне. Существует метод, который мы можем применить чтобы вёрстка не поплыла, если значение переменной CSS по какой-то причине было пустым.
.message__bubble {
    max-width: calc(100% - var(--actions-width, 70px));
}
Если переменная не определена, будет использован резервный вариант - 70px.

- Не использовать фиксированные ширину или высоту с элементом, который имеет содержимое разной длины

- Использовать min-height вместо height, width вместо min-width(для кнопок, например)

- Отключение повторения фона на большом экране.
.image {
    background-image: url('..');
    background-repeat: no-repeat; /* запрет повторения изображения */
}

- Вертикальные @media-запросы. Тестировать, меняя не только ширину, но и высоту экрана.

- Текст поверх изображений. При использовании текста поверх изображения важно учитывать случай, когда изображение не загружается. Как будет выглядеть текст? Можно исправить это, добавив фоновый цвет к <img>элементу. Этот фон будет виден только в том случае, если изображение не загрузится. 
.card__img {
    background-color: grey;
}

- Показываем полосу прокрутки везде только когда это необходимо.
.element {
    overflow-y: auto;
}

- Ширина контента с полосой прокрутки. Когда содержимое становится длиннее, добавление полосы прокрутки вызовет сдвиг макета. Мы можем зафиксировать ширину контента, чтобы скроллбар её не менял. Для этого напишем стили:
.element {
    scrollbar-gutter: stable;
}

- Минимальный размер контента в CSS-Flexbox. Если во flex-контейнере есть текстовый элемент или изображение, длина которого превышает длину самого элемента, браузер не будет их уменьшать. Это поведение по умолчанию для flexbox. Даже если мы используем overflow-wrap: break-word, это не сработает. Чтобы изменить это поведение, нам нужно установить min-width дочернего блока на 0,  из-за того, что значение по умолчанию min-width равно auto.
.card__title {
    overflow-wrap: break-word;
    min-width: 0;
}
То же самое относится и к flex-контейнеру, но вместо min-width: 0 мы будем использовать min-height: 0

- Минимальный размер содержимого в CSS-Grid. Подобно flexbox, CSS-сетка имеет минимальный размер содержимого по умолчанию для своих дочерних элементов, который равенauto. Это означает, что если есть элемент, который больше, чем элемент сетки, сетка переполнится (например, карусель). Чтобы исправить это, у нас есть три разных решения:
    - Использование minmax()
    - Применение min-width к элементу сетки
    - Добавление overflow: hidden элемента в сетку
Вариант с minmax():
@media (min-width: 1020px) {
    .wrapper {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 248px;
        grid-gap: 40px;
    }
}

- Auto Fit против Auto Fill. При использовании функции CSS-Grid minmax()важно выбрать между использованием параметров auto-fitили auto-fill. При неправильном использовании это может привести к неожиданным результатам.
При использовании функции minmax()параметрauto-fit расширяет элементы сетки, чтобы заполнить доступное пространство. В свою очередьauto-fillсохранит доступное пространство зарезервированным, без изменения ширины элементов сетки. 
repeat(auto-fit, minmax(250px, 1fr));
repeat(auto-fill, minmax(250px, 1fr));

- Использование position: sticky в CSS-Grid. Вы когда-нибудь пробовали использовать position: sticky с дочерним элементом grid-контейнера? По умолчанию, элементы grid растягиваются. В результате боковой элемент в приведенном ниже примере равен высоте основной секции. Чтобы заставить его работать должным образом, вам нужно сбросить свойство align-self
aside {
    align-self: start;
    position: sticky;
    top: 1rem;
}

- Группировка селекторов для разных браузеров. Не рекомендуется группировать селекторы, предназначенные для работы с разными браузерами. Например, для стилизации заполнителя ввода требуется несколько селекторов для каждого браузера. Если мы сгруппируем селекторы, согласно w3c все правило будет недействительным.
/* Не делайте так, пожалуйста! */
input::-webkit-input-placeholder,
input:-moz-placeholder {
    color: #222;
}
Вместо этого напишите так:
input::-webkit-input-placeholder {
    color: #222;
}
input:-moz-placeholder {
    color: #222;
}